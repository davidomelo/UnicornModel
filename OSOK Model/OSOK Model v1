datetime lastTradeDay;  // Variável global para armazenar o último dia de trading

//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
{
   // Inicializar o último dia de trading com a data atual
   lastTradeDay = iTime(NULL, PERIOD_D1, 0);  // O tempo de início do último candle diário
   return(INIT_SUCCEEDED);
}

//+------------------------------------------------------------------+
//| Expert tick function                                             |
//+------------------------------------------------------------------+
void OnTick()
{
   // Verificar se é um novo dia de trading
   datetime currentDay = iTime(NULL, PERIOD_D1, 0);  // O tempo de início do candle diário atual
   if (currentDay != lastTradeDay)
   {
      // Remover objetos do dia anterior
      RemoveObjectsFromPreviousDay(lastTradeDay);
      
      // Atualizar o dia de trading
      lastTradeDay = currentDay;
   }

   // Identificar e pintar as velas dos swings highs e lows
   IdentifyAndPaintSwingCandles();
}

//+------------------------------------------------------------------+
//| Função para identificar swings highs e lows e criar objetos gráficos para o dia atual |
//+------------------------------------------------------------------+
void IdentifyAndPaintSwingCandles()
{
   int totalBars = Bars(NULL, PERIOD_H1);  // Total de barras no gráfico de 1H
   double minDistancePips = 100;  // Distância mínima para um swing

   // Percorrer as últimas velas e detectar swings
   for (int i = 2; i < totalBars - 2; i++)  // Verificar barras anteriores e seguintes
   {
      datetime candleTime = iTime(NULL, PERIOD_H1, i);
      datetime currentDayStart = iTime(NULL, PERIOD_D1, 0);

      // Verificar se a vela pertence ao dia de trading atual
      if (candleTime < currentDayStart)
         continue;  // Ignorar velas de dias anteriores

      double high1 = iHigh(NULL, PERIOD_H1, i+1);
      double high2 = iHigh(NULL, PERIOD_H1, i);
      double high3 = iHigh(NULL, PERIOD_H1, i-1);

      double low1 = iLow(NULL, PERIOD_H1, i+1);
      double low2 = iLow(NULL, PERIOD_H1, i);
      double low3 = iLow(NULL, PERIOD_H1, i-1);

      // Verificar Swing High
      if (high2 > high1 && high2 > high3 && (high2 - low3) >= minDistancePips * Point())
      {
         Print("Swing High detectado na vela de índice ", i);
         PaintSwingCandles(i, clrRed);  // Pintar três velas do swing high
      }

      // Verificar Swing Low
      if (low2 < low1 && low2 < low3 && (high1 - low2) >= minDistancePips * Point())
      {
         Print("Swing Low detectado na vela de índice ", i);
         PaintSwingCandles(i, clrBlue);  // Pintar três velas do swing low
      }
   }
}

//+------------------------------------------------------------------+
//| Função para pintar as velas dos swings com retângulos gráficos para o dia atual |
//+------------------------------------------------------------------+
void PaintSwingCandles(int index, color swingColor)
{
   string dayString = TimeToString(lastTradeDay, TIME_DATE);

   // Criar objetos gráficos para cobrir as três velas que formam o swing
   for (int i = 0; i < 3; i++)  // Pintar três velas consecutivas
   {
      int barIndex = index - i;
      string obj_name = "swing_candle_" + dayString + "_" + IntegerToString(barIndex);

      // Verificar se o objeto já foi criado para essa vela
      if (ObjectFind(0, obj_name) == -1)
      {
         // Coletar dados da vela para desenhar o objeto retangular
         datetime timeOpen = iTime(NULL, PERIOD_H1, barIndex);      // Tempo de abertura da vela
         datetime timeClose = timeOpen + 3600;                      // Fechamento ajustado (uma hora)
         double high1 = iHigh(NULL, PERIOD_H1, barIndex);           // Máxima da vela
         double low1 = iLow(NULL, PERIOD_H1, barIndex);             // Mínima da vela
         double open1 = iOpen(NULL, PERIOD_H1, barIndex);           // Preço de abertura
         double close1 = iClose(NULL, PERIOD_H1, barIndex);         // Preço de fechamento

         // Definir o corpo da vela entre a abertura e o fechamento (retângulo)
         double topBody = MathMax(open1, close1);  // O maior entre abertura e fechamento
         double bottomBody = MathMin(open1, close1);  // O menor entre abertura e fechamento

         // Criar o retângulo preenchido para cobrir o corpo da vela
         bool created = ObjectCreate(0, obj_name + "_body", OBJ_RECTANGLE, 0, timeOpen, topBody, timeClose, bottomBody);
         if (created)
         {
            ObjectSetInteger(0, obj_name + "_body", OBJPROP_COLOR, swingColor);
            ObjectSetInteger(0, obj_name + "_body", OBJPROP_STYLE, STYLE_SOLID);
            ObjectSetInteger(0, obj_name + "_body", OBJPROP_WIDTH, 2);  // Tornar a borda mais visível
            ObjectSetInteger(0, obj_name + "_body", OBJPROP_BACK, false);  // Colocar à frente do gráfico
            ObjectSetInteger(0, obj_name + "_body", OBJPROP_FILL, true);   // Preencher o retângulo
            ObjectSetInteger(0, obj_name + "_body", OBJPROP_ZORDER, 1);    // Ordem de exibição mais alta
         }
      }
   }
}

//+------------------------------------------------------------------+
//| Função para remover objetos antigos do dia anterior              |
//+------------------------------------------------------------------+
void RemoveObjectsFromPreviousDay(datetime day)
{
   string dayString = TimeToString(day, TIME_DATE);  // Converter a data do dia anterior para string
   int totalObjects = ObjectsTotal(0);  // Contagem total de objetos no gráfico

   // Percorrer todos os objetos e remover aqueles associados ao dia anterior
   for (int i = totalObjects - 1; i >= 0; i--)
   {
      string obj_name = ObjectName(0, i);
      if (StringFind(obj_name, dayString) != -1)
      {
         // Remover o objeto associado ao dia anterior
         ObjectDelete(0, obj_name);
         Print("Objeto removido: ", obj_name);
      }
   }
}
